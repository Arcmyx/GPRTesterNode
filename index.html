<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Perlin Underground — Full Res Smooth (fixed zoom)</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/addons/p5.dom.min.js"></script>
    <style>
      html,
      body,
      canvas {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        box-sizing: border-box;
        overflow: hidden;
      }
      canvas {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 0 !important;
        display: block !important;
        background: transparent !important;
      }
      #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(30, 30, 30, 0.85);
        color: #fff;
        padding: 12px 16px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <button id="connectBtn">Connect</button>
      <button id="disconnectBtn" disabled>Disconnect</button>
      <button id="simulateBtn">Simulate</button>
      <div>
        <input
          id="manualInput"
          placeholder="Type UP/DOWN/LEFT/RIGHT or (x,y,z)"
        />
        <button id="sendManual">Send</button>
      </div>
      <div id="status">Status: disconnected</div>
      <div id="lastCmd">Last: —</div>
      <div id="log"></div>
    </div>

    <script id="vert" type="x-shader/x-vertex">
      attribute vec3 aPosition;
      varying vec2 vPos;
      void main() {
        vPos = aPosition.xy;
        gl_Position = vec4(aPosition, 1.0);
      }
    </script>

    <script id="frag" type="x-shader/x-fragment">
      precision highp float;
      uniform float uOffsetX;
      uniform float uOffsetY;
      uniform float uNoiseScale;
      uniform vec2 uResolution;

      float hash(vec2 p) {
        return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
      }
      float noise(vec2 p) {
        vec2 i = floor(p);
        vec2 f = fract(p);
        float a = hash(i);
        float b = hash(i + vec2(1.0, 0.0));
        float c = hash(i + vec2(0.0, 1.0));
        float d = hash(i + vec2(1.0, 1.0));
        vec2 u = f * f * (3.0 - 2.0 * f);
        return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
      }

      void main() {
        // uv uses effective scale; offsets are already converted to noise-space
        vec2 uv = (gl_FragCoord.xy * uNoiseScale) + vec2(uOffsetX, uOffsetY);
        float n = noise(uv);
        float col = n > 0.55 ? 0.2 : 0.8;
        gl_FragColor = vec4(vec3(col), 1.0);
      }
    </script>

    <script>
      // If running in Electron, keep ipcRenderer logic; harmless otherwise
      try {
        const { ipcRenderer } = require("electron");
        ipcRenderer.on("command", (event, cmd) => handleCommand(cmd));
        ipcRenderer.on("vectorCommand", (event, vec) => {
          if (Array.isArray(vec) && vec.length === 3)
            handleCommand(`(${vec[0]}, ${vec[1]}, ${vec[2]})`);
          else if (typeof vec === "string") handleCommand(vec);
          else if (
            vec &&
            typeof vec === "object" &&
            ["x", "y", "z"].every((k) => k in vec)
          )
            handleCommand(`(${vec.x}, ${vec.y}, ${vec.z})`);
        });
      } catch (e) {
        /* not running in electron; it's fine */
      }
    </script>

    <script>
      // --- Controls & tuning ---
      let port = null,
        reader = null,
        keepReading = false;
      // offsets are stored in screen pixels (intuitive)
      let offsetX = 0,
        offsetY = 0; // in noise units
      let targetOffsetX = 0,
        targetOffsetY = 0;
      let zoom = 1,
        targetZoom = 1;

      const baseNoiseScale = 0.006;
      const panStep = 40 * baseNoiseScale; // convert pixels to noise units
      const zoomStep = 0.12;
      const interp = 0.15;

      function log(msg) {
        const el = document.createElement("div");
        el.textContent = msg;
        document.getElementById("log").prepend(el);
      }

      async function connectSerial() {
        try {
          port = await navigator.serial.requestPort();
          await port.open({ baudRate: 115200 });
          if (!port.readable)
            throw new Error("Port is not readable after opening.");
          document.getElementById("status").textContent = "Status: connected";
          document.getElementById("connectBtn").disabled = true;
          document.getElementById("disconnectBtn").disabled = false;
          startReadingLoop();
        } catch (e) {
          log("Failed to connect: " + (e.message || e));
          console.error(e);
        }
      }
      async function disconnectSerial() {
        keepReading = false;
        if (reader) {
          try {
            await reader.cancel();
          } catch (e) {}
          reader = null;
        }
        if (port) {
          try {
            await port.close();
          } catch (e) {}
          port = null;
        }
        document.getElementById("status").textContent = "Status: disconnected";
        document.getElementById("connectBtn").disabled = false;
        document.getElementById("disconnectBtn").disabled = true;
      }

      async function startReadingLoop() {
        keepReading = true;
        const textDecoder = new TextDecoderStream();
        port.readable.pipeTo(textDecoder.writable);
        reader = textDecoder.readable.getReader();
        let buffer = "";
        while (keepReading) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            buffer += value;
            let lines = buffer.split(/\r?\n/);
            buffer = lines.pop();
            for (const line of lines) handleCommand(line.trim());
          }
        }
      }

      // Accept either numeric tuples "(x,y,z)" or simple text commands "UP", "LEFT", etc.
      function handleCommand(cmd) {
        if (!cmd) return;
        document.getElementById("lastCmd").textContent = "Last: " + cmd;
        // try tuple first
        const tupleMatch = cmd
          .toString()
          .match(
            /^\(?\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*\)?$/i
          );
        let x = 0,
          y = 0,
          z = 0;
        if (tupleMatch) {
          x = parseFloat(tupleMatch[1]);
          y = parseFloat(tupleMatch[2]);
          z = parseFloat(tupleMatch[3]);
        } else {
          // parse simple textual commands
          const s = cmd.toString().trim().toUpperCase();
          const map = {
            UP: [0, 0, -1],
            DOWN: [0, 0, 1],
            LEFT: [-1, 0, 0],
            RIGHT: [1, 0, 0],
            "ZOOM IN": [0, 1, 0],
            ZOOMOUT: [0, -1, 0],
            ZOOMOUT: [0, -1, 0],
            "+": [0, 1, 0],
            "-": [0, -1, 0],
          };
          if (map[s]) {
            [x, y, z] = map[s];
          } else {
            // unknown command — ignore
            return;
          }
        }

        // clamp inputs
        x = Math.max(-1, Math.min(1, x));
        y = Math.max(-1, Math.min(1, y));
        z = Math.max(-1, Math.min(1, z));

        // apply panning in pixel space, and zoom additively
        const panStepNoise = panStep / zoom; // panStep is already in noise units
        // pan in noise units
        targetOffsetX += x * panStepNoise;
        targetOffsetY += z * panStepNoise;

        // zoom
        targetZoom = Math.max(0.2, Math.min(targetZoom + y * zoomStep, 5));
      }

      // wire UI
      document.getElementById("connectBtn").onclick = connectSerial;
      document.getElementById("disconnectBtn").onclick = disconnectSerial;
      document.getElementById("simulateBtn").onclick = () => {
        const cmds = ["UP", "DOWN", "LEFT", "RIGHT", "(0,1,0)", "(0,-1,0)"];
        handleCommand(cmds[Math.floor(Math.random() * cmds.length)]);
      };
      document.getElementById("sendManual").onclick = () => {
        let val = document.getElementById("manualInput").value.trim();
        if (val) handleCommand(val);
        document.getElementById("manualInput").value = "";
      };

      // --- p5 sketch + shader ---
      let terrainShader;
      let sketch = (p) => {
        p.setup = function () {
          p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          terrainShader = p.createShader(
            document.getElementById("vert").textContent,
            document.getElementById("frag").textContent
          );
          p.noStroke();
        };

        p.draw = function () {
          // smoothing towards target values
          offsetX += (targetOffsetX - offsetX) * interp;
          offsetY += (targetOffsetY - offsetY) * interp;
          zoom += (targetZoom - zoom) * interp;

          p.background(10, 15, 30);
          // offsets are in "noise units", not pixels
          const effectiveNoiseScale = baseNoiseScale * zoom; // zoom scales features
          offsetX += (targetOffsetX - offsetX) * interp;
          offsetY += (targetOffsetY - offsetY) * interp;
          zoom += (targetZoom - zoom) * interp;

          terrainShader.setUniform("uOffsetX", offsetX);
          terrainShader.setUniform("uOffsetY", offsetY);
          terrainShader.setUniform("uNoiseScale", effectiveNoiseScale);

          p.shader(terrainShader);
          // draw full-screen quad in clip space
          p.beginShape(p.TRIANGLE_STRIP);
          p.vertex(-1, -1, 0);
          p.vertex(1, -1, 0);
          p.vertex(-1, 1, 0);
          p.vertex(1, 1, 0);
          p.endShape();
          p.resetShader();

          // onscreen debug
          p.fill(255);
          p.textSize(12);
          p.text(
            `OffsetX: ${offsetX.toFixed(1)} OffsetY: ${offsetY.toFixed(
              1
            )} Zoom: ${zoom.toFixed(2)}`,
            -p.width / 2 + 10,
            -p.height / 2 + 15
          );
        };

        p.windowResized = function () {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
        };
      };
      window._pInst = new p5(sketch);
    </script>
  </body>
</html>
