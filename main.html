<!--<script>
  // Electron IPC command handling (like index.html)
  let ipcRenderer;
  try {
    ipcRenderer = require("electron").ipcRenderer;
  } catch (e) {}
  if (ipcRenderer) {
    ipcRenderer.on("command", (event, cmd) => {
      handleCommand(cmd);
    });
    ipcRenderer.on("vectorCommand", (event, vec) => {
      // Accept array, string, or object with x, y, z
      if (Array.isArray(vec) && vec.length === 3) {
        handleCommand(`(${vec[0]}, ${vec[1]}, ${vec[2]})`);
      } else if (typeof vec === "string") {
        handleCommand(vec);
      } else if (
        vec &&
        typeof vec === "object" &&
        ["x", "y", "z"].every((k) => k in vec)
      ) {
        handleCommand(`(${vec.x}, ${vec.y}, ${vec.z})`);
      }
    });
}
</script>
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Perlin Underground — Full Res Smooth</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.8.0/addons/p5.dom.min.js"></script>

    <style>
      html,
      body,
      canvas {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        box-sizing: border-box;
      }
      canvas {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 0 !important;
        display: block !important;
        background: black;
      }
      #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(30, 30, 30, 0.85);
        color: #fff;
        padding: 12px 16px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      #ui input {
        width: 150px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <!-- Serial buttons removed -->
      <button id="simulateBtn">Simulate</button>
      <button id="switchFreqBtn">Switch frequencies</button>
      <div>
        <input id="manualInput" placeholder="UP/DOWN/LEFT/RIGHT or (x,y,z)" />
        <button id="sendManual">Send</button>
      </div>
      <!-- Serial status removed -->
      <div id="lastCmd">Input: —</div>
      <div id="log"></div>
    </div>

    <!-- Shaders -->
    <script id="vert" type="x-shader/x-vertex">
      attribute vec3 aPosition;
      varying vec2 vPos;
      void main() {
        vPos = aPosition.xy;
        gl_Position = vec4(aPosition, 1.0);
      }
    </script>

    <script id="frag" type="x-shader/x-fragment">
          precision highp float;
          uniform float uOffsetX;
          uniform float uOffsetY;
          uniform float uNoiseScale;

      uniform vec2 uResolution;
      uniform bool uSharpMode;


          // Real Perlin noise (gradient noise) implementation
          vec2 fade(vec2 t) {
            return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
          }

          float grad(vec2 hash, vec2 p) {
            // 8 directions
            float angle = 6.2831853 * fract(sin(dot(hash, vec2(12.9898,78.233))) * 43758.5453);
            return dot(p, vec2(cos(angle), sin(angle)));
          }


          float perlin(vec2 p) {
            vec2 pi = floor(p);
            vec2 pf = fract(p);
            // Hash corners
            vec2 h00 = pi;
            vec2 h10 = pi + vec2(1.0, 0.0);
            vec2 h01 = pi + vec2(0.0, 1.0);
            vec2 h11 = pi + vec2(1.0, 1.0);
            // Gradients
            float g00 = grad(h00, pf);
            float g10 = grad(h10, pf - vec2(1.0, 0.0));
            float g01 = grad(h01, pf - vec2(0.0, 1.0));
            float g11 = grad(h11, pf - vec2(1.0, 1.0));
            // Interpolation
            vec2 f = fade(pf);
            float nx0 = mix(g00, g10, f.x);
            float nx1 = mix(g01, g11, f.x);
            float nxy = mix(nx0, nx1, f.y);
            // Normalize to [0,1]
            return 0.5 + 0.5 * nxy;
          }

          // Fractal Brownian Motion for more detail

          float fbm(vec2 p, bool sharp) {
            float total = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            int octaves = sharp ? 20 : 5;
            float freqMult = sharp ? 10.0 : 2.0;
            float ampMult = sharp ? 0.18 : 0.5;
            for (int i = 0; i < 8; i++) {
              if (i >= octaves) break;
              total += perlin(p * frequency) * amplitude;
              frequency *= freqMult;
              amplitude *= ampMult;
            }
            return total;
          }

          // Simulate an archaeology-tuned GPR scan
          void main() {
            // GPR scans are horizontally banded, with strong reflections and noise
            vec2 uv = gl_FragCoord.xy * uNoiseScale * 1.2 + vec2(uOffsetX, uOffsetY);
      float n = fbm(uv, uSharpMode);
            // Add horizontal banding (simulate time/depth slices)
            float band = sin(uv.y * 6.0) * 0.08;
            // Simulate strong reflectors (buried objects)
            float reflect = smoothstep(0.62, 0.65, n) * 0.7;
            // Add subtle random noise for realism
            float grain = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453) * 0.07 - 0.035;
            // Combine all effects
            float gpr = n + band + reflect + grain;
            gpr = clamp((gpr - 0.45) * 2.0 + 0.5, 0.0, 1.0); // high contrast
            // Gray color ramp: #111111 (dark) to #7d7d7d (light) for normal, brighter for sharp
            vec3 dark, light;
            if (uSharpMode) {
              dark = vec3(0.32, 0.32, 0.32); // dark gray
              light = vec3(0.95, 0.95, 0.95); // almost white
            } else {
              dark = vec3(0.066, 0.066, 0.066); // #111111
              light = vec3(0.49, 0.49, 0.49);   // #7d7d7d
            }
            vec3 color = mix(dark, light, gpr);
            gl_FragColor = vec4(color, 1.0);
          }
    </script>

    <script>
      // --- Electron IPC ---
      let ipcRenderer;
      try {
        ipcRenderer = require("electron").ipcRenderer;
      } catch (e) {}
      if (ipcRenderer) {
        ipcRenderer.on("command", (event, cmd) => handleCommand(cmd));
        ipcRenderer.on("vectorCommand", (event, vec) => {
          // Accept {x, z} or array [x, z] or string
          if (Array.isArray(vec) && vec.length >= 2) {
            handleCommand(`(${vec[0]}, 0, ${vec[1]})`);
          } else if (typeof vec === "string") {
            handleCommand(vec);
          } else if (
            vec &&
            typeof vec === "object" &&
            "x" in vec &&
            "z" in vec
          ) {
            handleCommand(`(${vec.x}, 0, ${vec.z})`);
          }
        });
      }

      // --- UI Logging ---
      function log(msg) {
        const el = document.createElement("div");
        el.textContent = msg;
        document.getElementById("log").prepend(el);
      }

      // Serial functionality removed

      // --- Pan and Zoom State ---
      let baseNoiseScale = 0.006;
      const panSpeed = 80;
      let panStep = panSpeed * baseNoiseScale;
      // Zoom functionality removed

      let offsetX = 0,
        offsetZ = 0;
      let targetOffsetX = 0,
        targetOffsetZ = 0;

      // --- Command Handling ---
      // Store the latest joystick dx/dz
      let lastDx = 0,
        lastDz = 0;
      function handleCommand(cmd) {
        if (!cmd) return;
        document.getElementById("lastCmd").textContent = "Last: " + cmd;

        let dx = 0,
          dz = 0;
        const tupleMatch = cmd
          .toString()
          .match(
            /^\(?\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*\)?$/
          );
        if (tupleMatch) {
          dx = parseFloat(tupleMatch[1]);
          dz = parseFloat(tupleMatch[3]);
        } else {
          const s = cmd.toString().trim().toUpperCase();
          const map = {
            UP: [0, 1],
            DOWN: [0, -1],
            LEFT: [-1, 0],
            RIGHT: [1, 0],
          };
          if (map[s]) [dx, dz] = map[s];
          else return;
        }

        lastDx = Math.max(-1, Math.min(1, dx));
        lastDz = -Math.max(-1, Math.min(1, dz));
      }

      // Apply pan at a fixed interval (every 100ms)
      setInterval(() => {
        targetOffsetX += lastDx * panStep;
        targetOffsetZ += lastDz * panStep;
      }, 100);

      // --- UI Wiring ---
      // Serial button handlers removed
      document.getElementById("simulateBtn").onclick = () => {
        const cmds = ["UP", "DOWN", "LEFT", "RIGHT", "(0,1,0)", "(0,-1,0)"];
        handleCommand(cmds[Math.floor(Math.random() * cmds.length)]);
      };
      document.getElementById("sendManual").onclick = () => {
        const val = document.getElementById("manualInput").value.trim();
        if (val) handleCommand(val);
        document.getElementById("manualInput").value = "";
      };

      // Snap camera to city overlay origin on 'x' key press
      window.addEventListener("keydown", function (e) {
        if (e.key === "x" || e.key === "X") {
          targetOffsetX = 0;
          targetOffsetZ = 0;
        }
      });

      // --- p5 Sketch ---
      let terrainShader;
      let useSharpNoise = false;
      let lastTime = performance.now();
      let cityOverlayImg, citySharpImg;
      let cityOverlayLoaded = false,
        citySharpLoaded = false;
      let font;
      let sketch = (p) => {
        p.preload = function () {
          cityOverlayImg = p.loadImage("city-overlay.png", () => {
            cityOverlayLoaded = true;
          });
          citySharpImg = p.loadImage("city-sharp.png", () => {
            citySharpLoaded = true;
          });
          font = p.loadFont("proximanova_regular.ttf");
        };
        p.setup = function () {
          p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          terrainShader = p.createShader(
            document.getElementById("vert").textContent,
            document.getElementById("frag").textContent
          );
          p.noStroke();
          p.textFont(font);

          // Button event for switching frequencies
          document.getElementById("switchFreqBtn").onclick = function () {
            useSharpNoise = !useSharpNoise;
            this.textContent = useSharpNoise
              ? "Switch to low frequency"
              : "Switch to high frequency";
            if (useSharpNoise) {
              baseNoiseScale = 0.004;
              panStep = panSpeed * baseNoiseScale;
            } else {
              baseNoiseScale = 0.006;
              panStep = panSpeed * baseNoiseScale;
            }
            console.log(
              "Switched to " + (useSharpNoise ? "high" : "low") + " frequency"
            );
          };
        };

        p.draw = function () {
          // Use background(0) for reliable clearing in WEBGL
          p.background(0);

          let now = performance.now();
          let dt = (now - lastTime) / 1000;
          lastTime = now;

          const panSpeed = 4.0; // units/sec
          offsetX += (targetOffsetX - offsetX) * Math.min(panSpeed * dt, 1.0);
          offsetZ += (targetOffsetZ - offsetZ) * Math.min(panSpeed * dt, 1.0);

          const effectiveNoiseScale = baseNoiseScale;
          p.shader(terrainShader);
          terrainShader.setUniform("uOffsetX", offsetX);
          terrainShader.setUniform("uOffsetY", offsetZ);
          terrainShader.setUniform("uNoiseScale", effectiveNoiseScale);
          terrainShader.setUniform("uSharpMode", useSharpNoise);

          p.beginShape(p.TRIANGLE_STRIP);
          p.vertex(-1, -1, 0);
          p.vertex(1, -1, 0);
          p.vertex(-1, 1, 0);
          p.vertex(1, 1, 0);
          p.endShape();
          p.resetShader();
          // Overlay city GPR scan image and effects ABOVE the noise, but moving with world offset
          let img, loaded;
          if (useSharpNoise) {
            img = citySharpImg;
            loaded = citySharpLoaded;
          } else {
            img = cityOverlayImg;
            loaded = cityOverlayLoaded;
          }
          if (loaded && img && img.width > 0 && img.height > 0) {
            let imgW = 2048;
            let imgH = 3072;
            if (useSharpNoise) {
              imgW *= 1.5;
              imgH *= 1.5;
            }
            // Calculate screen position so overlay moves with noise
            let screenX = p.width / 2 - (offsetX * 0.861) / baseNoiseScale;
            let screenY = p.height / 2 + (offsetZ * 0.861) / baseNoiseScale;
            screenX += 2000;
            p.resetMatrix();
            p.ortho();
            p.push();
            p.drawingContext.disable(p.drawingContext.DEPTH_TEST);

            // draw overlay image with translucency
            p.tint(255, 255); // 180/255 alpha for translucency
            p.image(img, screenX - imgW / 2, screenY - imgH / 2, imgW, imgH);
            p.tint(255, 255); // reset tint to opaque for any later drawing

            // optional debug border
            //p.noFill();
            //p.stroke(255, 0, 0);
            //p.rect(screenX - imgW / 2, screenY - imgH / 2, imgW, imgH);

            p.drawingContext.enable(p.drawingContext.DEPTH_TEST);
            p.pop();
          } else if (!cityOverlayLoaded) {
            // Show debug text if image not loaded
            p.resetMatrix();
            p.ortho();
            p.push();
            p.fill(255, 0, 0);
            p.textSize(18);
            p.textFont(font);
            p.text("city-overlay.png not loaded", 40, 60);
            p.pop();
          }

          // --- GPR Glitch Effects ---
          p.resetMatrix();
          p.ortho();
          p.translate(-p.width / 2, -p.height / 2);
          console.log("Canvas size:", p.width, p.height);
          /*
          // Horizontal glitch lines (many, subtle)
          let glitchLineCount = 12 + Math.floor(Math.random() * 8);
          for (let i = 0; i < glitchLineCount; i++) {
            let y = Math.floor(Math.random() * p.height);
            let x1 = Math.floor(Math.random() * p.width * 0.7);
            let x2 = Math.floor(Math.random() * p.width);
            if (x2 < x1) [x1, x2] = [x2, x1]; // ensure left-to-right
            let alpha = 0 + Math.random() * 80;
            //let thickness = 0.5 + Math.random() / 4;
            let thickness = 0.75;
            p.push();
            p.stroke(255, 255, 255, alpha);
            p.strokeWeight(thickness);
            p.line(x1, y, x2, y);
            p.pop();
          }
          */
          // Horizontal glitch lines (always visible)
          const minGlitchDistance = 10;
          const maxGlitchDistance = 50;

          function generateRandomPoint(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
          }

          for (let i = 0; i < 12 + Math.floor(Math.random() * 8); i++) {
            let y = generateRandomPoint(0, p.height - 1);
            let x1 = generateRandomPoint(
              minGlitchDistance,
              p.width - minGlitchDistance
            );
            let x2 = generateRandomPoint(
              minGlitchDistance,
              p.width - minGlitchDistance
            );

            while (x1 === x2) {
              x2 = generateRandomPoint(
                minGlitchDistance,
                p.width - minGlitchDistance
              );
            }

            let alpha = 0 + Math.random() * 80;
            let thickness = 0.75;

            p.push();
            p.stroke(255, 255, 255, alpha);
            p.strokeWeight(thickness);
            p.line(x1, y, x2, y);
            p.pop();
          }

          // Occasional major glitch bars (rare, bold)
          if (Math.random() < 0.2) {
            let barCount = 1 + Math.floor(Math.random() * 2);
            for (let i = 0; i < barCount; i++) {
              let y = Math.floor(Math.random() * p.height);
              let barHeight = 6 + Math.random() * 16;
              let alpha = 120 + Math.random() * 100;
              let color = 200 + Math.random() * 55;
              p.push();
              p.noStroke();
              p.fill(color, color, color, alpha);
              p.rect(0, y, p.width, barHeight);
              p.pop();
            }
          }
          // UI text overlay
          p.push();
          p.fill(255);
          p.textSize(12);
          p.text(
            `OffsetX: ${offsetX.toFixed(1)} OffsetZ: ${offsetZ.toFixed(1)}`,
            10,
            20
          );
          p.pop();
        };

        p.windowResized = function () {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
        };
      };

      window._pInst = new p5(sketch);
    </script>
  </body>
</html>
