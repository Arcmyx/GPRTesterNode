<!--<script>
  // Electron IPC command handling (like index.html)
  let ipcRenderer;
  try {
    ipcRenderer = require("electron").ipcRenderer;
  } catch (e) {}
  if (ipcRenderer) {
    ipcRenderer.on("command", (event, cmd) => {
      handleCommand(cmd);
    });
    ipcRenderer.on("vectorCommand", (event, vec) => {
      // Accept array, string, or object with x, y, z
      if (Array.isArray(vec) && vec.length === 3) {
        handleCommand(`(${vec[0]}, ${vec[1]}, ${vec[2]})`);
      } else if (typeof vec === "string") {
        handleCommand(vec);
      } else if (
        vec &&
        typeof vec === "object" &&
        ["x", "y", "z"].every((k) => k in vec)
      ) {
        handleCommand(`(${vec.x}, ${vec.y}, ${vec.z})`);
      }
    });
}
</script>
-->
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Perlin Underground — Full Res Smooth</title>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/p5.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/p5@1.6.0/lib/addons/p5.dom.min.js"></script>
    <style>
      html,
      body,
      canvas {
        margin: 0;
        padding: 0;
        width: 100vw;
        height: 100vh;
        overflow: hidden;
        box-sizing: border-box;
      }
      canvas {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 0 !important;
        display: block !important;
        background: black;
      }
      #ui {
        position: fixed;
        top: 10px;
        left: 10px;
        z-index: 10;
        background: rgba(30, 30, 30, 0.85);
        color: #fff;
        padding: 12px 16px;
        border-radius: 8px;
        font-family: sans-serif;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      #ui input {
        width: 150px;
      }
    </style>
  </head>
  <body>
    <div id="ui">
      <!-- Serial buttons removed -->
      <button id="simulateBtn">Simulate</button>
      <div>
        <input id="manualInput" placeholder="UP/DOWN/LEFT/RIGHT or (x,y,z)" />
        <button id="sendManual">Send</button>
      </div>
      <!-- Serial status removed -->
      <div id="lastCmd">Input: —</div>
      <div id="log"></div>
    </div>

    <!-- Shaders -->
    <script id="vert" type="x-shader/x-vertex">
      attribute vec3 aPosition;
      varying vec2 vPos;
      void main() {
        vPos = aPosition.xy;
        gl_Position = vec4(aPosition, 1.0);
      }
    </script>

    <script id="frag" type="x-shader/x-fragment">
      precision highp float;
      uniform float uOffsetX;
      uniform float uOffsetY;
      uniform float uNoiseScale;
      uniform vec2 uResolution;


      // Real Perlin noise (gradient noise) implementation
      vec2 fade(vec2 t) {
        return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
      }

      float grad(vec2 hash, vec2 p) {
        // 8 directions
        float angle = 6.2831853 * fract(sin(dot(hash, vec2(12.9898,78.233))) * 43758.5453);
        return dot(p, vec2(cos(angle), sin(angle)));
      }


      float perlin(vec2 p) {
        vec2 pi = floor(p);
        vec2 pf = fract(p);
        // Hash corners
        vec2 h00 = pi;
        vec2 h10 = pi + vec2(1.0, 0.0);
        vec2 h01 = pi + vec2(0.0, 1.0);
        vec2 h11 = pi + vec2(1.0, 1.0);
        // Gradients
        float g00 = grad(h00, pf);
        float g10 = grad(h10, pf - vec2(1.0, 0.0));
        float g01 = grad(h01, pf - vec2(0.0, 1.0));
        float g11 = grad(h11, pf - vec2(1.0, 1.0));
        // Interpolation
        vec2 f = fade(pf);
        float nx0 = mix(g00, g10, f.x);
        float nx1 = mix(g01, g11, f.x);
        float nxy = mix(nx0, nx1, f.y);
        // Normalize to [0,1]
        return 0.5 + 0.5 * nxy;
      }

      // Fractal Brownian Motion for more detail
      float fbm(vec2 p) {
        float total = 0.0;
        float amplitude = 0.5;
        float frequency = 1.0;
        for (int i = 0; i < 5; i++) {
          total += perlin(p * frequency) * amplitude;
          frequency *= 2.0;
          amplitude *= 0.5;
        }
        return total;
      }

      // Simulate an archaeology-tuned GPR scan
      void main() {
        // GPR scans are horizontally banded, with strong reflections and noise
        vec2 uv = gl_FragCoord.xy * uNoiseScale * 1.2 + vec2(uOffsetX, uOffsetY);
        float n = fbm(uv);
        // Add horizontal banding (simulate time/depth slices)
        float band = sin(uv.y * 6.0) * 0.08;
        // Simulate strong reflectors (buried objects)
        float reflect = smoothstep(0.62, 0.65, n) * 0.7;
        // Add subtle random noise for realism
        float grain = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233))) * 43758.5453) * 0.07 - 0.035;
        // Combine all effects
        float gpr = n + band + reflect + grain;
        gpr = clamp((gpr - 0.45) * 2.0 + 0.5, 0.0, 1.0); // high contrast
        // Gray color ramp: #111111 (dark) to #7d7d7d (light)
        vec3 dark = vec3(0.066, 0.066, 0.066); // #111111
        vec3 light = vec3(0.49, 0.49, 0.49);   // #7d7d7d
        vec3 color = mix(dark, light, gpr);
        gl_FragColor = vec4(color, 1.0);
      }
    </script>

    <script>
      // --- Electron IPC ---
      let ipcRenderer;
      try {
        ipcRenderer = require("electron").ipcRenderer;
      } catch (e) {}
      if (ipcRenderer) {
        ipcRenderer.on("command", (event, cmd) => handleCommand(cmd));
        ipcRenderer.on("vectorCommand", (event, vec) => {
          // Accept {x, z} or array [x, z] or string
          if (Array.isArray(vec) && vec.length >= 2) {
            handleCommand(`(${vec[0]}, 0, ${vec[1]})`);
          } else if (typeof vec === "string") {
            handleCommand(vec);
          } else if (
            vec &&
            typeof vec === "object" &&
            "x" in vec &&
            "z" in vec
          ) {
            handleCommand(`(${vec.x}, 0, ${vec.z})`);
          }
        });
      }

      // --- UI Logging ---
      function log(msg) {
        const el = document.createElement("div");
        el.textContent = msg;
        document.getElementById("log").prepend(el);
      }

      // Serial functionality removed

      // --- Pan and Zoom State ---
      const baseNoiseScale = 0.006;
      const panStep = 40 * baseNoiseScale;
      // Zoom functionality removed

      let offsetX = 0,
        offsetZ = 0;
      let targetOffsetX = 0,
        targetOffsetZ = 0;

      // --- Command Handling ---
      // Store the latest joystick dx/dz
      let lastDx = 0,
        lastDz = 0;
      function handleCommand(cmd) {
        if (!cmd) return;
        document.getElementById("lastCmd").textContent = "Last: " + cmd;

        let dx = 0,
          dz = 0;
        const tupleMatch = cmd
          .toString()
          .match(
            /^\(?\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*,\s*(-?\d*\.?\d+)\s*\)?$/
          );
        if (tupleMatch) {
          dx = parseFloat(tupleMatch[1]);
          dz = parseFloat(tupleMatch[3]);
        } else {
          const s = cmd.toString().trim().toUpperCase();
          const map = {
            UP: [0, 1],
            DOWN: [0, -1],
            LEFT: [-1, 0],
            RIGHT: [1, 0],
          };
          if (map[s]) [dx, dz] = map[s];
          else return;
        }

        lastDx = Math.max(-1, Math.min(1, dx));
        lastDz = -Math.max(-1, Math.min(1, dz));
      }

      // Apply pan at a fixed interval (every 100ms)
      setInterval(() => {
        targetOffsetX += lastDx * panStep;
        targetOffsetZ += lastDz * panStep;
      }, 100);

      // --- UI Wiring ---
      // Serial button handlers removed
      document.getElementById("simulateBtn").onclick = () => {
        const cmds = ["UP", "DOWN", "LEFT", "RIGHT", "(0,1,0)", "(0,-1,0)"];
        handleCommand(cmds[Math.floor(Math.random() * cmds.length)]);
      };
      document.getElementById("sendManual").onclick = () => {
        const val = document.getElementById("manualInput").value.trim();
        if (val) handleCommand(val);
        document.getElementById("manualInput").value = "";
      };

      // Snap camera to city overlay origin on 'x' key press
      window.addEventListener("keydown", function (e) {
        if (e.key === "x" || e.key === "X") {
          targetOffsetX = 0;
          targetOffsetZ = 0;
        }
      });

      // --- p5 Sketch ---
      let terrainShader;
      let lastTime = performance.now();
      let cityOverlayImg;
      let cityOverlayLoaded = false;

      let sketch = (p) => {
        p.preload = function () {
          cityOverlayImg = p.loadImage("city-overlay.png", () => {
            cityOverlayLoaded = true;
          });
        };
        p.setup = function () {
          p.createCanvas(p.windowWidth, p.windowHeight, p.WEBGL);
          terrainShader = p.createShader(
            document.getElementById("vert").textContent,
            document.getElementById("frag").textContent
          );
          p.noStroke();
          p.textFont("sans-serif");
        };

        p.draw = function () {
          let now = performance.now();
          let dt = (now - lastTime) / 1000;
          lastTime = now;

          const panSpeed = 4.0; // units/sec
          offsetX += (targetOffsetX - offsetX) * Math.min(panSpeed * dt, 1.0);
          offsetZ += (targetOffsetZ - offsetZ) * Math.min(panSpeed * dt, 1.0);

          const effectiveNoiseScale = baseNoiseScale;

          p.shader(terrainShader);
          terrainShader.setUniform("uOffsetX", offsetX);
          terrainShader.setUniform("uOffsetY", offsetZ);
          terrainShader.setUniform("uNoiseScale", effectiveNoiseScale);

          p.beginShape(p.TRIANGLE_STRIP);
          p.vertex(-1, -1, 0);
          p.vertex(1, -1, 0);
          p.vertex(-1, 1, 0);
          p.vertex(1, 1, 0);
          p.endShape();
          p.resetShader();

          // Overlay city GPR scan image always at the world origin (0,0)
          if (cityOverlayLoaded) {
            p.push();
            p.resetMatrix();
            p.translate(-p.width / 2, -p.height / 2, 0); // map WEBGL (0,0 center) to top-left
            p.imageMode(p.CORNER);
            let imgW = 1024;
            let imgH = 1536;
            p.image(
              cityOverlayImg,
              p.width / 2 - imgW / 2,
              p.height / 2 - imgH / 2,
              imgW,
              imgH
            );

            // debug rect
            p.noFill();
            p.stroke(255, 0, 0);
            p.strokeWeight(3);
            p.rect(p.width / 2 - imgW / 2, p.height / 2 - imgH / 2, imgW, imgH);
            p.pop();
          }

          p.push();
          p.resetMatrix();
          p.fill(255);
          p.textSize(12);
          p.text(
            `OffsetX: ${offsetX.toFixed(1)} OffsetZ: ${offsetZ.toFixed(1)}`,
            10,
            20
          );
          p.pop();
        };

        p.windowResized = function () {
          p.resizeCanvas(p.windowWidth, p.windowHeight);
        };
      };

      window._pInst = new p5(sketch);
    </script>
  </body>
</html>
